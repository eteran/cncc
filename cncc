#!/usr/bin/env python3

from __future__ import annotations

import difflib
import os
import re
import sys
from dataclasses import dataclass
from re import Pattern
from typing import List, Optional

import click
import yaml
from clang.cindex import (
    AccessSpecifier,
    CompilationDatabase,
    CursorKind,
    Index,
    LibclangError,
)

FORMAT = '{}:{}:{}: "{}" does not conform to pattern "{}" associated with {}'
DEFAULT_STYLE = "~/.cncc.style"
NAMED_KINDS = {kind.name.lower(): kind for kind in CursorKind.get_all_kinds()}


@dataclass(frozen=True)
class StyleRule:
    name: str = None
    kind: str = None
    regex: Pattern[str] = None
    access_specifier: str = None

    @staticmethod
    def create_name(rule: Dict[str, str]) -> str:
        if "access_specifier" in rule:
            return f"{rule['access_specifier']}:{rule['kind']}"

        return rule["kind"]

    @classmethod
    def create(cls, rule: Dict[str, str]) -> StyleRule:

        try:
            return cls(
                name=cls.create_name(rule),
                kind=NAMED_KINDS[rule["kind"]],
                regex=re.compile(rule["pattern"]),
                access_specifier=rule.get("access_specifier"),
            )
        except KeyError:
            sys.exit("Rule missing pattern specifier")

        sys.exit("Invalid rule entry")


def load_style_rules(style) -> List[StyleRule]:

    try:
        with open(style) as style_file:
            rules = yaml.safe_load(style_file)
    except FileNotFoundError:
        sys.exit(f"Style file {style!r} was not found")

    try:
        return [StyleRule.create(rule) for rule in rules]
    except KeyError as e:
        print(f"{style}: {e.message} is not a valid CursorKind")
        suggestions = difflib.get_close_matches(e.message, NAMED_KINDS.keys(), n=1, cutoff=0.8)
        if suggestions:
            print(f"Did you mean CursorKind: {suggestions[0]}")
        sys.exit(1)


def rule_for_node(rule_db, node) -> Optional[StyleRule]:
    for rule in rule_db:
        if node.kind == rule.kind:
            if node.access_specifier is AccessSpecifier.INVALID or rule.access_specifier is None or rule.access_specifier.upper() == node.access_specifier.name:
                return rule

    return None


def arguments_for_file(compile_db, f: str) -> List[str]:
    if not compile_db:
        return []

    commands = compile_db.getCompileCommands(f)
    arguments = [arg for cmd in commands for arg in cmd.arguments]

    # remove the compiler executable
    arguments = arguments[1:]

    try:
        index = arguments.index("--")
        return arguments[:index]
    except ValueError:
        return arguments


@click.command()
@click.option("--style", default=os.path.expanduser(DEFAULT_STYLE), help=f"user-defined style file, defaults to {DEFAULT_STYLE!r}")
@click.option("--dbdir", default=None, help="build path is used to read a 'compile_commands.json' compile command database")
@click.option("--list-kinds", help="Print a listing of all the known object kinds and then exit", is_flag=True, show_default=True, default=False)
@click.argument("files", nargs=-1)
def main(style: str, dbdir: str, list_kinds: bool, files: List[str]) -> None:

    if list_kinds:
        for kind in NAMED_KINDS.keys():
            print(kind)
        sys.exit(0)

    if not files:
        sys.exit(0)

    compile_db: CompilationDatabase = None
    if dbdir:
        compile_db = CompilationDatabase.fromDirectory(dbdir)

    rule_db = load_style_rules(style)

    def local(node):
        return node.location.file and node.location.file.name in files

    def invalid(node):

        rule = rule_for_node(rule_db, node)
        if not rule:
            return False

        spelling = node.spelling
        if not spelling:
            return False

        return not rule.regex.match(spelling)

    for f in files:

        arguments = arguments_for_file(compile_db, f)

        index = Index.create()
        unit = index.parse(f, args=arguments)
        cursor = unit.cursor

        notify = [node for node in cursor.walk_preorder() if local(node) and invalid(node)]

        for node in notify:

            rule = rule_for_node(rule_db, node)

            msg = FORMAT.format(
                node.location.file.name,
                node.location.line,
                node.location.column,
                node.displayname,
                rule.regex.pattern,
                rule.name,
            )
            print(msg)

    sys.exit(1 if notify else 0)


if __name__ == "__main__":
    try:
        main()
    except LibclangError as e:
        sys.exit(e)
